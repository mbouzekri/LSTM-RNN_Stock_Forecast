# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1muc0DcV6ntqIBVNI4G4bkTYwyMtdRlwm

Import of needed libraries to process data
"""

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the Keras libraries and packages
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

"""Extracting the data set that we will use to train the machine learning model. We only need the "Open Stock Price"
"""

# Just predicting the "Open Stock Price" for Google. So extracting 1 column.
training_set_raw = pd.read_csv('GOOGL_Stock_Price_Train.csv')
training_set = training_set_raw.iloc[:,1:2].values
training_set_raw = training_set_raw[0:1008]

"""Feature Scaling"""

# Feature Scaling
# Will use Normalisation as the Scaling function.
# Default range for MinMaxScaler is 0 to 1, which is what we want. So no arguments in it.
 # Will fit the training set to it and get it scaled and replace the original set.
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler()
training_set = sc.fit_transform(training_set)

# Getting the inputs and the ouputs
# Restricting the input and output based on how LSTM functions.
X_train = training_set[0:1008]
y_train = training_set[1:1009]

# Reshaping - Adding time interval as a dimension for input.
X_train = np.reshape(X_train, (1008, 1, 1))

# Initialising the RNN
# Creating an object of Sequential class to create the RNN.
regressor = Sequential()

# Adding the input layer and the LSTM layer
# 4 memory units, sigmoid activation function and (None time interval with 1 attribute as input)
regressor.add(LSTM(units = 4, activation = 'sigmoid', input_shape = (None, 1)))

# Adding the output layer
# 1 nueron in the output layer for 1 dimensional output
regressor.add(Dense(units = 1))

# Compiling the RNN
# Compiling all the layers together.
# Loss helps in manipulation of weights in NN.
regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')

# Fitting the RNN to the Training set
# Number of epochs increased for better convergence.
regressor.fit(X_train, y_train, batch_size = 32, epochs = 200)

# Part 3 - Making the predictions and visualising the results

# Getting the real stock price of 2023
test_set = pd.read_csv('GOOGL_Stock_Price_Test.csv')
real_stock_price = test_set.iloc[:,1:2].values

# Getting the predicted stock price of 2023
inputs = real_stock_price
inputs = sc.transform(inputs)
inputs = np.reshape(inputs, (23, 1, 1))
predicted_stock_price = regressor.predict(inputs)
predicted_stock_price = sc.inverse_transform(predicted_stock_price)
dates = pd.to_datetime(test_set['Date'])

# Visualising the results
plt.plot(dates, real_stock_price, color = 'red', label = 'Real Google Stock Price')
plt.plot(dates, predicted_stock_price, color = 'green', label = 'Predicted Google Stock Price')
plt.title('Google Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Google Stock Price')
plt.legend()
plt.xticks(rotation=45)
plt.show()

# Part 4 - Evaluating the RNN

# Making predictions for the entire dataset
# Getting the real stock price of 2019 - 2023
real_stock_price_train = pd.read_csv('GOOGL_Stock_Price_Train.csv')
real_stock_price_train = real_stock_price_train.iloc[:,1:2].values


# Getting the predicted stock price of 2019 - 2023
predicted_stock_price_train = regressor.predict(X_train)
predicted_stock_price_train = sc.inverse_transform(predicted_stock_price_train)

# Visualising the results
dates = pd.to_datetime(training_set_raw['Date'])
plt.plot(dates.values, real_stock_price_train[1:], color = 'red', label = 'Real Google Stock Price')
plt.plot(dates,predicted_stock_price_train, color = 'blue', label = 'Predicted Google Stock Price')
plt.title('Google Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Google Stock Price')
plt.xticks(rotation=45)
plt.legend()
plt.show()

import math
from sklearn.metrics import mean_squared_error
rmse = math.sqrt(mean_squared_error(real_stock_price, predicted_stock_price))
print(rmse / np.mean(real_stock_price) * 100)